Great tutorial on 2D collision
http://www.metanetsoftware.com/technique/tutorialA.html


------------------
Calculating resultant velocity:
    Elastic collision
------------------
SIMPLE, BOOTLEG PHYSICS:
(DXi, DYi) => (DXf, DYf)
if horizontal wall,
    DXf = -DXi
    DYf = DYi
if vertical wall,
    DXf = DXi
    DYf = -DYi

LEGIT PHYSICS:
"Newton's Rule (i.e. the conservation of momentum) applies to the components of velocity resolved along the common normal surfaces of the colliding bodies at the point of contact. In the case of the two spheres the velocity components involved are the components resolved along the line of centers during the contact. Consequently, the components of velocity perpendicular to the line of centers will be unchanged during the impact." 

-- find the final velocities in the normal reference frame
-- the x velocities will obey the rules for a 1-D collision
set v1fxr = ((m1-m2)*v1xr+(m2+m2)*v2xr)/(m1+m2)
set v2fxr = ((m1+m1)*v1xr+(m2-m1)*v2xr)/(m1+m2)
-- the y velocities will not be changed
set v1fyr = v1yr
set v2fyr = v2yr

We now have the 'after collision' velocities, but we have to transform the components back to the standard x-y reference frame. In this particular case, the velocity of the red puck was entirely in the standard y-direction (so our x-velocity in the standard reference frame is zero).

The relevant code (once again) is very dependent on angles!

-- convert back to the standard x,y coordinates
set v1fx = cos(phi)*v1fxr+cos(phi+pi()/2)*v1fyr
set v1fy = sin(phi)*v1fxr+sin(phi+pi()/2)*v1fyr
set v2fx = cos(phi)*v2fxr+cos(phi+pi()/2)*v2fyr
set v2fy = sin(phi)*v2fxr+sin(phi+pi()/2)*v2fyr


------------------
Drawing to the Screen
------------------
320 * 200 = 64000 dec bytes to represent the screen
(319, 0) = 319dec or 13F hex
(0, 1) = 320dec or 140 hex
offset = (row * 320) + column

"double buffer"
    use a part of memory where we prep a frame before drawing it

Ports: 3C8h is used to set color (output color index), 
    3C7h is used for reading palette values (output color index)
    3C9h is used to output color component data in RGB.
	------------------
		MODE X
	------------------
	The offset M of pixel N
	 in display memory is M = N/4, and the plane P of pixel N is P = N mod 4.  For
	 display memory writes, the plane is selected by setting bit P of the Map Mask
	 register (Sequence Controller register 2) to 1 and all other bits to 0; for
	 display memory reads, the plane is selected by setting the Read Map register
	 (Graphics Controller register 4) to P.

Listing Five (page 156)
 overcomes both these problems by tailoring the fill technique to the
 organization of display memory.  Each plane is filled in its entirety in one
 burst before the next plane is processed, so only five OUTs are required in
 all, and REP STOS can indeed be used.

	------------------
		MODE X
	------------------
	The offset M of pixel N
	 in display memory is M = N/4, and the plane P of pixel N is P = N mod 4.  For
	 display memory writes, the plane is selected by setting bit P of the Map Mask
	 register (Sequence Controller register 2) to 1 and all other bits to 0; for
	 display memory reads, the plane is selected by setting the Read Map register
	 (Graphics Controller register 4) to P.

	Listing Five (page 156)
	 overcomes both these problems by tailoring the fill technique to the
	 organization of display memory.  Each plane is filled in its entirety in one
	 burst before the next plane is processed, so only five OUTs are required in
	 all, and REP STOS can indeed be used.


------------------
BMP format
------------------
Pixels are stored "upside-down", starting in bottom left, going left-to-right, bottom-to-top

http://www.fileformat.info/format/bmp/egff.htm

http://en.wikipedia.org/wiki/BMP_file_format
typedef struct _WinBMPFileHeader
{
	WORD   FileType;     /* File type, always 4D42h (ASCII "BM") */
	DWORD  FileSize;     /* Size of the file in bytes (only if file is compressed, else 0) */
	WORD   Reserved1;    /* Always 0 */
	WORD   Reserved2;    /* Always 0 */
	DWORD  BitmapOffset; /* Starting position of image data in bytes */
		OURS = 3e, so bitmap BEGINS at 3E
} WINBMPFILEHEADER;

HEADER: (40dec long)
	12h 	4 	the bitmap width in pixels (signed integer).
					12h = b, so width 11
	16h 	4 	the bitmap height in pixels (signed integer).
					16h = b, so width 11
	1Ch 	2 	the number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.
					1Ch = 1, so monochrome
	1Eh 	4 	the compression method being used. See the next table for a list of possible values.
					-OURS: none
	22h 	4 	the image size. This is the size of the raw bitmap data (see below), and should not be confused with the file size.

The following are the BMP RLE markers:

00 00           End of scan line
00 01           End of bitmap data
00 02 XX YY     Run offset marker

************************************************************
PREDEFINED INTERRUPTS GIVEN:
************************************************************
	Get Current Video Mode	10h		0Fh
		Return:
		AH = number of character columns
		AL = display mode (see #00010 at AH=00h)
		BH = active page (see AH=05h)
************************************************************
	Set Video Mode			10h		00h
************************************************************
	Scroll Up Window		10h		06h
		AH = 06h
		AL = number of lines by which to scroll up (00h = clear entire window)
		BH = attribute used to write blank lines at bottom of window
		CH,CL = row,column of window's upper left corner
		DH,DL = row,column of window's lower right corne
		RETURN: Nothing
************************************************************
	Direct Console Input	21h		06h
		AH = 06h
		DL = character (except FFh)

		Return:
		AL = character output (despite official docs which state nothing is returned) (at least DOS 2.1-7.0) 
************************************************************
	Get System Time			21h		2Ch
		RETURN:
		CH = hour CL = minute DH = second DL = 1/100 seconds

		NOTE: On most systems, the resolution of the system clock is about 5/100sec, so returned times generally do not increment by 1. On some systems, DL may always return 00h 
************************************************************
	Open Existing File		21h		3Dh
		AH = 3Dh
		AL = access and sharing modes (see #01402)
		DS:DX -> ASCIZ filename
		CL = attribute mask of files to look for (server call only)

		Return:
		CF clear if successful AX = file handle CF set on error AX = error code (01h,02h,03h,04h,05h,0Ch,56h) (see #01680 at AH=59h)

		Notes: File pointer is set to start of file. If SHARE or a network is loaded, the file open may fail if the file is already open, depending on the combination of sharing modes (see #01403,#01404). File handles which are inherited from a parent also inherit sharing and access restrictions. Files may be opened even if given the hidden or system attributes. Under the FlashTek X-32 DOS extender, the pointer is in DS:EDX. DR DOS checks the system password or explicitly supplied password at the end of the filename (following a semicolon) against the reserved field in the directory entry before allowing access. Sharing modes are only effective on local drives if SHARE is loaded 

		Bit(s)  Description     (Table 01402)
		2-0    access mode.
		000 read only.
		001 write only.
		010 read/write.
		011 (DOS 5+ internal) passed to redirector on EXEC to allow
		case-sensitive filenames
		3      reserved (0)
		6-4    sharing mode (DOS 3.0+) (see #01403).
		000 compatibility mode.
		001 "DENYALL" prohibit both read and write access by others.
		010 "DENYWRITE" prohibit write access by others.
		011 "DENYREAD" prohibit read access by others.
		100 "DENYNONE" allow full access by others.
		111 network FCB (only available during server call)
		7      inheritance.
		If set, file is private to current process and will not be inherited by child processes
************************************************************
	Read From File			21h		3Fh
		AH = 3Fh
		BX = file handle
		CX = number of bytes to read
		DS:DX -> buffer for data

		Return:
		CF clear if successful AX = number of bytes actually read (0 if at EOF before call) CF set on error AX = error code (05h,06h) (see #01680 at AH=59h/BX=0000h) 

************************************************************
	Close File				21h		3Eh
		Return:
		CF clear if successful
		AX destroyed
		CF set on error
		AX = error code (06h) (see #01680 at AH=59h/BX=0000h)
************************************************************
	Terminate With Return	21h		4Ch
************************************************************
